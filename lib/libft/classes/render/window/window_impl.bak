#include "window.h"
#include <stdio.h>
#include <string.h>

// Make these functions accessible to other files
void window_render_impl(t_window *self)
{
    static int render_count = 0;
    render_count++;

    printf("ðŸ–¼ï¸  === WINDOW_RENDER_IMPL #%d ===\n", render_count);

    if (!self)
    {
        printf("âŒ window_render_impl: self is NULL\n");
        return;
    }

    printf("   Window: %p\n", self);
    printf("   Size: %dx%d\n", self->width, self->height);
    printf("   MLX pointers: mlx=%p, win=%p, img=%p\n", self->mlx_ptr, self->win_ptr, self->img_ptr);
    printf("   Image data: %p\n", self->img_data);

    if (!self->mlx_ptr)
    {
        printf("âŒ window_render_impl: mlx_ptr is NULL\n");
        return;
    }

    if (!self->win_ptr)
    {
        printf("âŒ window_render_impl: win_ptr is NULL\n");
        return;
    }

    if (!self->img_ptr)
    {
        printf("âŒ window_render_impl: img_ptr is NULL\n");
        return;
    }

    // Test the image data before rendering
    if (self->img_data && render_count <= 3)
    {
        unsigned int *pixel_data = (unsigned int *)self->img_data;
        printf("   Image verification:\n");
        printf("     First pixel: 0x%08X\n", pixel_data[0]);
        printf("     Pixel at (100,100): 0x%08X\n", pixel_data[100 * self->width + 100]);
        printf("     Last pixel: 0x%08X\n", pixel_data[self->width * self->height - 1]);
    }

    printf("ðŸŽ¨ Calling mlx_put_image_to_window...\n");

    // Present the frame
    int result = mlx_put_image_to_window(self->mlx_ptr, self->win_ptr, self->img_ptr, 0, 0);
    printf("   mlx_put_image_to_window returned: %d\n", result);

    // Force X11 to process events and display
    printf("ðŸ”„ Calling mlx_do_sync for immediate display...\n");
    if (self->mlx_ptr)
    {
        mlx_do_sync(self->mlx_ptr);
        printf("   mlx_do_sync completed\n");
    }

    // Also try flushing X11 directly if available
    printf("ðŸ”„ Trying additional display flush...\n");

    printf("âœ… === WINDOW_RENDER_IMPL #%d COMPLETE ===\n", render_count);

    // Render layers in z-order (from back to front)
    t_layer *layers_sorted[1000];
    int layer_count = 0;

    // Collect all layers
    t_layer *current = self->layers;
    while (current && layer_count < 1000)
    {
        layers_sorted[layer_count++] = current;
        current = current->next;
    }

    // Sort layers by z_index (bubble sort for simplicity)
    for (int i = 0; i < layer_count - 1; i++)
    {
        for (int j = 0; j < layer_count - i - 1; j++)
        {
            if (layers_sorted[j]->z_index > layers_sorted[j + 1]->z_index)
            {
                t_layer *temp = layers_sorted[j];
                layers_sorted[j] = layers_sorted[j + 1];
                layers_sorted[j + 1] = temp;
            }
        }
    }

    // Debug: print layer order
    if (layer_count > 0)
    {
        printf("Rendering %d layers in z-order: ", layer_count);
        for (int i = 0; i < layer_count; i++)
        {
            printf("z=%d ", layers_sorted[i]->z_index);
        }
        printf("\n");
    }

    // Render objects in each layer - use vtable through pointer
    for (int i = 0; i < layer_count; i++)
    {
        t_layer *layer = layers_sorted[i];
        printf("Rendering layer z=%d with %zu objects\n", layer->z_index, layer->object_count);

        for (size_t j = 0; j < layer->object_count; j++)
        {
            t_object *obj = layer->objects[j];
            // Use object through pointer - vtable is accessible
            if (obj && obj->vtable && obj->vtable->draw)
            {
                printf("Drawing object %zu in layer z=%d\n", j, layer->z_index);
                obj->vtable->draw(obj, self);
            }
        }
    }
}

void window_clear_impl(t_window *self)
{
    if (!self || !self->img_data)
    {
        printf("âŒ window_clear_impl: Invalid parameters - self=%p, img_data=%p\n",
               self, self ? self->img_data : NULL);
        return;
    }

    printf("ðŸ§¹ === WINDOW_CLEAR_IMPL DEBUG ===\n");
    printf("   Input bg_color: 0x%06X\n", self->bg_color);
    printf("   Window size: %dx%d\n", self->width, self->height);

    int total_pixels = self->width * self->height;
    int *pixel_data = (int *)self->img_data;

    // Use the background color directly - no complex format conversion
    unsigned int final_color = self->bg_color & 0xFFFFFF;
    
    printf("   Final color: 0x%06X\n", final_color);
    printf("   Clearing %d pixels...\n", total_pixels);

    for (int i = 0; i < total_pixels; i++)
    {
        pixel_data[i] = final_color;
    }

    // Verify first few pixels
    printf("   Verification - first 3 pixels:\n");
    for (int i = 0; i < 3; i++)
    {
        printf("     pixel[%d] = 0x%08X (expected: 0x%06X) %s\n",
               i, pixel_data[i], final_color,
               ((unsigned int)pixel_data[i] == final_color) ? "âœ…" : "âŒ");
    }

    printf("âœ… window_clear_impl: Cleared successfully\n");
    printf("=== END WINDOW_CLEAR_IMPL DEBUG ===\n");
}


void window_add_object_impl(t_window *self, t_object *obj, int z_index)
{
    if (!self || !obj)
        return;

    // Find or create layer
    t_layer *layer = self->layers;
    while (layer && layer->z_index != z_index)
    {
        layer = layer->next;
    }

    if (!layer)
    {
        layer = layer_new(z_index);
        if (!layer)
            return;
        layer->next = self->layers;
        self->layers = layer;
    }

    layer_add_object(layer, obj);
}

void window_remove_object_impl(t_window *self, t_object *obj)
{
    if (!self || !obj)
        return;

    t_layer *current = self->layers;
    while (current)
    {
        layer_remove_object(current, obj);
        current = current->next;
    }
}

void window_set_background_impl(t_window *self, int color)
{
    if (!self)
        return;
    self->bg_color = color;
}

void window_resize_impl(t_window *self, int width, int height)
{
    if (!self)
        return;

    printf("ðŸ”„ === WINDOW_RESIZE_IMPL ===\n");
    printf("   Old size: %dx%d\n", self->width, self->height);
    printf("   New size: %dx%d\n", width, height);

    // Update window dimensions
    self->width = width;
    self->height = height;

    // Recreate image buffer with new dimensions
    if (self->img_ptr)
    {
        printf("ðŸ—‘ï¸  Destroying old image buffer...\n");
        mlx_destroy_image(self->mlx_ptr, self->img_ptr);
        self->img_ptr = NULL;
        self->img_data = NULL;
    }

    printf("ðŸ–¼ï¸  Creating new image buffer %dx%d...\n", width, height);
    self->img_ptr = mlx_new_image(self->mlx_ptr, width, height);
    if (self->img_ptr)
    {
        self->img_data = mlx_get_data_addr(self->img_ptr, &self->bpp,
                                           &self->size_line, &self->endian);
        printf("âœ… New image buffer created successfully\n");
        printf("   img_data=%p, bpp=%d, size_line=%d, endian=%d\n",
               self->img_data, self->bpp, self->size_line, self->endian);
    }
    else
    {
        printf("âŒ Failed to create new image buffer!\n");
    }
    
    printf("âœ… === WINDOW_RESIZE_IMPL COMPLETE ===\n");
}

int window_handle_events_impl(t_window *self)
{
    if (!self)
        return 0;

    // Basic event handling - for now just return if window should continue
    return !self->should_close;
}
