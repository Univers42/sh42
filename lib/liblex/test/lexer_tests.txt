# === BASIC TESTS ===
# Simple identifiers
jkfdkla => TOKEN_IDENTIFIER TOKEN_EOF
clear => TOKEN_IDENTIFIER TOKEN_EOF
ls => TOKEN_IDENTIFIER TOKEN_EOF

# Unterminated string error
echo "hello jasfd => TOKEN_IDENTIFIER TOKEN_ERR

# Quoted strings
echo "hello" => TOKEN_IDENTIFIER TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF
echo 'world' => TOKEN_IDENTIFIER TOKEN_SINGLE_QUOTED_STRING TOKEN_EOF

# === REDIRECTION TESTS ===
# Pipes and redirections
ls | grep test => TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF
cat < input.txt => TOKEN_IDENTIFIER TOKEN_REDIR_IN TOKEN_IDENTIFIER TOKEN_EOF
echo test > output.txt => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_REDIR_OUT TOKEN_IDENTIFIER TOKEN_EOF
echo test >> output.txt => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_REDIR_APPEND TOKEN_IDENTIFIER TOKEN_EOF

# Heredoc
cat << EOF => TOKEN_IDENTIFIER TOKEN_REDIR_HEREDOC TOKEN_IDENTIFIER TOKEN_EOF
cat <<- EOF => TOKEN_IDENTIFIER TOKEN_REDIR_HEREDOC_STRIP TOKEN_IDENTIFIER TOKEN_EOF

# FD redirections
exec 3>&1 => TOKEN_IDENTIFIER TOKEN_NUMBER TOKEN_REDIR_FD_OUT TOKEN_NUMBER TOKEN_EOF
exec 3<&0 => TOKEN_IDENTIFIER TOKEN_NUMBER TOKEN_REDIR_FD_IN TOKEN_NUMBER TOKEN_EOF

# Clobber and inout
echo x >| file => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_REDIR_CLOBBER TOKEN_IDENTIFIER TOKEN_EOF
sort <> data.txt => TOKEN_IDENTIFIER TOKEN_REDIR_INOUT TOKEN_IDENTIFIER TOKEN_EOF

# === FLAGS AND OPTIONS ===
ls -la => TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_EOF
grep --color => TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_EOF
gcc -Wall -Wextra => TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_FLAG TOKEN_EOF
make --no-print-directory => TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_EOF

# === COMPLEX PIPELINES ===
echo "hello\n" | wc -l @ | filter -things |> <(new process) => TOKEN_IDENTIFIER TOKEN_DOUBLE_QUOTED_STRING TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_WORD TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_PIPE TOKEN_REDIR_OUT TOKEN_SUBST_IN TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF

# Multi-stage pipeline
cat file | grep pattern | sort | uniq -c => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_EOF

# === EXPANSIONS ===
# Variable expansions
$HOME => TOKEN_DOLLAR TOKEN_IDENTIFIER TOKEN_EOF
${VAR} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${VAR:-default} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_COLON_DASH TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${VAR:=default} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_COLON_EQUAL TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${#VAR} => TOKEN_PAR_EXP_START TOKEN_POUND TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF

# Command substitution
$(cmd) => TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF
$(echo hello | wc -l) => TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_RIGHT_PAREN TOKEN_EOF

# Arithmetic expansion
$((2 + 2)) => TOKEN_ARITH_EXP_START TOKEN_NUMBER TOKEN_OP_ADD TOKEN_NUMBER TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF
$((x++)) => TOKEN_ARITH_EXP_START TOKEN_IDENTIFIER TOKEN_OP_INCREMENT TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF

# Special parameters
$? => TOKEN_DOLLAR_QUESTION TOKEN_EOF
$$ => TOKEN_DOLLAR_DOLLAR TOKEN_EOF
$! => TOKEN_DOLLAR_BANG TOKEN_EOF
$0 => TOKEN_DOLLAR_ZERO TOKEN_EOF
$# => TOKEN_DOLLAR_HASH TOKEN_EOF
$* => TOKEN_DOLLAR_STAR TOKEN_EOF
$@ => TOKEN_DOLLAR_AT TOKEN_EOF
$- => TOKEN_DOLLAR_DASH TOKEN_EOF

# === GLOBBING ===
ls *.txt => TOKEN_IDENTIFIER TOKEN_GLOB_STAR TOKEN_IDENTIFIER TOKEN_EOF
rm file?.log => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_GLOB_QUESTION TOKEN_IDENTIFIER TOKEN_EOF
echo [abc] => TOKEN_IDENTIFIER TOKEN_GLOB_BRACKET_OPEN TOKEN_IDENTIFIER TOKEN_GLOB_BRACKET_CLOSE TOKEN_EOF

# === PATH AND TILDE ===
~/ => TOKEN_TILDE TOKEN_OP_DIV TOKEN_EOF
~/Documents => TOKEN_TILDE TOKEN_OP_DIV TOKEN_IDENTIFIER TOKEN_EOF
~user/file => TOKEN_TILDE TOKEN_IDENTIFIER TOKEN_OP_DIV TOKEN_IDENTIFIER TOKEN_EOF

# === LOGICAL OPERATORS ===
cmd1 && cmd2 => TOKEN_IDENTIFIER TOKEN_AMP_AMP TOKEN_IDENTIFIER TOKEN_EOF
cmd1 || cmd2 => TOKEN_IDENTIFIER TOKEN_PIPE_PIPE TOKEN_IDENTIFIER TOKEN_EOF
cmd1 ; cmd2 => TOKEN_IDENTIFIER TOKEN_SEMICOLON TOKEN_IDENTIFIER TOKEN_EOF

# === GROUPING ===
(cmd) => TOKEN_LEFT_PAREN TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF
{ cmd; } => TOKEN_LEFT_BRACE TOKEN_IDENTIFIER TOKEN_SEMICOLON TOKEN_RIGHT_BRACE TOKEN_EOF
( cmd1 && cmd2 ) => TOKEN_LEFT_PAREN TOKEN_IDENTIFIER TOKEN_AMP_AMP TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF

# === PROCESS SUBSTITUTION ===
diff <(cmd1) <(cmd2) => TOKEN_IDENTIFIER TOKEN_SUBST_IN TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_SUBST_IN TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF
tee >(cmd) => TOKEN_IDENTIFIER TOKEN_SUBST_OUT TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_EOF

# === STRESS TESTS - EDGE CASES ===
# Empty quotes
"" => TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF
'' => TOKEN_SINGLE_QUOTED_STRING TOKEN_EOF

# Nested quotes (should work)
echo "hello 'world'" => TOKEN_IDENTIFIER TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF
echo 'hello "world"' => TOKEN_IDENTIFIER TOKEN_SINGLE_QUOTED_STRING TOKEN_EOF

# Escaped characters in double quotes
echo "hello\nworld" => TOKEN_IDENTIFIER TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF
echo "quote: \"text\"" => TOKEN_IDENTIFIER TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF

# Multiple redirections
cmd < in > out 2>&1 => TOKEN_IDENTIFIER TOKEN_REDIR_IN TOKEN_IDENTIFIER TOKEN_REDIR_OUT TOKEN_IDENTIFIER TOKEN_NUMBER TOKEN_REDIR_FD_OUT TOKEN_NUMBER TOKEN_EOF

# Crazy pipeline
cat << EOF | grep -v "^#" | sed 's/foo/bar/' | awk '{print $1}' > output.txt => TOKEN_IDENTIFIER TOKEN_REDIR_HEREDOC TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_DOUBLE_QUOTED_STRING TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_SINGLE_QUOTED_STRING TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_SINGLE_QUOTED_STRING TOKEN_REDIR_OUT TOKEN_IDENTIFIER TOKEN_EOF

# Arithmetic operators in $(())
$((a + b * c - d / e % f)) => TOKEN_ARITH_EXP_START TOKEN_IDENTIFIER TOKEN_OP_ADD TOKEN_IDENTIFIER TOKEN_OP_MULT TOKEN_IDENTIFIER TOKEN_OP_MINUS TOKEN_IDENTIFIER TOKEN_OP_DIV TOKEN_IDENTIFIER TOKEN_OP_MOD TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF
$((x += 10)) => TOKEN_ARITH_EXP_START TOKEN_IDENTIFIER TOKEN_ASS_PLUS TOKEN_NUMBER TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF
$((y *= 2)) => TOKEN_ARITH_EXP_START TOKEN_IDENTIFIER TOKEN_ASS_MULT TOKEN_NUMBER TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF

# Bang patterns
!pattern => TOKEN_BANG TOKEN_IDENTIFIER TOKEN_EOF
!! => TOKEN_BANG_BANG TOKEN_EOF

# Hash comments (note: lexer might handle # as TOKEN_POUND)
# this is a comment => TOKEN_POUND TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF

# Background jobs
sleep 10 & => TOKEN_IDENTIFIER TOKEN_NUMBER TOKEN_AMPERSAND TOKEN_EOF
(cmd1; cmd2) & => TOKEN_LEFT_PAREN TOKEN_IDENTIFIER TOKEN_SEMICOLON TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_AMPERSAND TOKEN_EOF

# === MALFORMED / ERROR CASES ===
# Unclosed quotes
echo "unclosed => TOKEN_IDENTIFIER TOKEN_ERR
echo 'unclosed => TOKEN_IDENTIFIER TOKEN_ERR

# Unclosed expansions
${VAR => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_EOF
$(cmd => TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_EOF
$((expr => TOKEN_ARITH_EXP_START TOKEN_IDENTIFIER TOKEN_EOF

# Stray characters
@ => TOKEN_WORD TOKEN_EOF
% => TOKEN_PERCENT TOKEN_EOF
^ => TOKEN_WORD TOKEN_EOF

# Mixed operators
>&2 => TOKEN_REDIR_FD_OUT TOKEN_NUMBER TOKEN_EOF
<&- => TOKEN_REDIR_FD_IN TOKEN_OP_MINUS TOKEN_EOF

# === WHITESPACE EDGE CASES ===
# Leading/trailing spaces (whitespace ignored by default)
  echo   hello   => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF
	echo	hello	 => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF

# === SUPER COMPLEX REAL-WORLD EXAMPLES ===
# Git-like command
git log --oneline --graph --decorate --all => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_FLAG TOKEN_FLAG TOKEN_FLAG TOKEN_EOF

# Docker-like command
docker run -it --rm -v $(pwd):/app nginx => TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_FLAG TOKEN_FLAG TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_COLON_DASH TOKEN_OP_DIV TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF

# Complex find + xargs
find . -name "*.c" -type f | xargs grep -l "main" => TOKEN_IDENTIFIER TOKEN_DOT TOKEN_FLAG TOKEN_DOUBLE_QUOTED_STRING TOKEN_FLAG TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_FLAG TOKEN_DOUBLE_QUOTED_STRING TOKEN_EOF

# Nested command substitution
echo $(echo $(echo hello)) => TOKEN_IDENTIFIER TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_CMD_SUBST_START TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_RIGHT_PAREN TOKEN_RIGHT_PAREN TOKEN_EOF

# Complex parameter expansion
${VAR#prefix} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_POUND TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${VAR##prefix} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_POUND_POUND TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${VAR%suffix} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_PERCENT TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF
${VAR%%suffix} => TOKEN_PAR_EXP_START TOKEN_IDENTIFIER TOKEN_PERCENT_PERCENT TOKEN_IDENTIFIER TOKEN_RIGHT_BRACE TOKEN_EOF

# === LEXEME ASSERTION TESTS ===
echo "x" => TOKEN_IDENTIFIER(echo) TOKEN_DOUBLE_QUOTED_STRING(x) TOKEN_EOF
ls -la => TOKEN_IDENTIFIER(ls) TOKEN_FLAG(-la) TOKEN_EOF
cat file.txt => TOKEN_IDENTIFIER(cat) TOKEN_IDENTIFIER(file.txt) TOKEN_EOF

echo |< echo segf => TOKEN_IDENTIFIER TOKEN_PIPE TOKEN_REDIR_IN TOKEN_IDENTIFIER TOKEN_IDENTIFIER TOKEN_EOF
echo segf >| echo is this invalid => ...
echo >          >           < "echo" => ...
echo >          >         | echo kekw => ...
echo >          >         | echo super valid => ...
unset PATH => ...
ls => ...
unset PATH => ...
env => ...
env => ...
export => ...
echo $USER => ...
echo $HOME => ...
echo $HOME$NOTHING$USER$ => ...
pwd => ...
unset PATH => ...
echo $HOME$NOTHING$USER$ => ...
unset PATH => ...
unset USER => ...
cd - => ...
pwd => ...
echo "no env over here" => ...
exit asd => ...
exit 5 => ...
exit 5 asd => ...
unset OLDPWD => ...
cd - => ...
pwd => ...
cd => ...
cd ~ => ...
/bin/ls => ...
cd /bin/ => ...
./ls => ...
ls => ...
export T=bazd => ...
echo "$T" "meg" => ...
cd /bin/ => ...
ls => ...
export a="asd" b="de" o= c="hellomi" X => ...
unset o => ...
export a="asd" b="de" o= c="hellomi" X => ...
unset X => ...
export a="asd" b="de" o= c="hellomi" X => ...
unset o a X b c => ...
export a="asd" b="de" o= c="hellomi" X => ...
unset o asd B x X wqd c => ...
unset PATH => ...
cat => ...
cd .. => ...
exit => ...
unset PATH => ...
pwd => ...
cd => ...
pwd => ...
unset PATH => ...
pwd => ...
cd - => ...
pwd => ...
exit => ...
unset PATH => ...
pwd => ...
cd ~ => ...
pwd => ...
unset PATH => ...
pwd => ...
cd ~ => ...
pwd => ...
cd - => ...
pwd => ...
/bin/cat Makefile > out >>out1 >out2 => ...
/bin/cat Makefile > out >>out1 >out2 => ...
/bin/rm -rf out => ...
/bin/rm -rf out1 => ...
/bin/rm -rf out2 => ...
/bin/cat Makefile > out >>out1 >out2 | /bin/cat << stop > out3 => ...
asdsada => ...
asd => ...
stop => ...
/bin/cat Makefile > out >>out1 >out2 | /bin/cat << stop > out3 => ...
123 => ...
123 => ...
12 => ...
stop => ...
/bin/rm -rf out => ...
/bin/rm -rf out1 => ...
/bin/rm -rf out2 => ...
/bin/rm -rf out3 => ...
/bin/cat Makefile > out >>out1 >out2 | /bin/cat << stop > out3 | /bin/ls => ...
testinator => ...
stop => ...
/bin/rm -rf out => ...
/bin/rm -rf out1 => ...
/bin/rm -rf out2 => ...
/bin/rm -rf out3 => ...
/bin/cat Makefile > out >>out1 >out2 | /bin/cat << stop > out3 | /bin/ls > > | /bin/cat << file => ...
will make you cry => ...
stop => ...
/bin/rm -rf out => ...
/bin/rm -rf out1 => ...
/bin/rm -rf out2 => ...
/bin/rm -rf out3 => ...
cd .. => ...
pwd => ...
/bin/cat Makefile > out >>out1 >out2 > out3 >> out4 => ...
/bin/cat Makefile > out >>out1 >out2 > out3 >> out4 => ...
/bin/rm -rf out => ...
/bin/rm -rf out1 => ...
/bin/rm -rf out2 => ...
/bin/rm -rf out3 => ...
/bin/rm -rf out4 => ...
> out => ...
/bin/rm -rf out => ...
< out => ...
/bin/rm -rf out => ...
| => ...
"" => ...
'' => ...
>> out => ...
/bin/rm -rf out => ...
<< out => ...
where => ...
is => ...
MY => ...
ENV? => ...
BRING IT BACK! => ...
out => ...
((echo 1) | (echo 2) | (echo 3 | (echo 4))) => ...
echo 1 | (echo 2 || echo 3 && echo 4) || echo 5 | echo 6 => ...
echo 1 | (grep 1) | cat | (wc -l) => ...
(/bin/echo 1 | /bin/echo 2 && ((/bin/echo 3 | /bin/echo 3) | (/bin/echo 4 | /bin/echo 4))) => ...
(exit 4) => ...
(sleep 0 && (exit 4)) => ...
(echo 1 | echo 2) | (exit 2) => ...
/bin/echo 1 && /bin/echo 2 => ...
cat file_does_not_exist && /bin/echo 2 => ...
/bin/echo 1 || /bin/echo 2 => ...
cat file_does_not_exist || /bin/echo 2 => ...
/bin/echo 1 && /bin/echo 2 && /bin/echo 3 => ...
/bin/echo 1 || /bin/echo 2 || /bin/echo 3 => ...
/bin/echo 1 && /bin/echo 2 | /bin/echo 3 => ...
/bin/echo 1 || /bin/echo 2 | /bin/echo 3 => ...
/bin/echo 1 && cat file_does_not_exist | /bin/echo 3 => ...
/bin/echo 1 && /bin/echo 3 | cat file_does_not_exist => ...
/bin/echo 1 || cat file_does_not_exist | /bin/echo 3 => ...
/bin/echo 1 || /bin/echo 2 | cat file_does_not_exist => ...
cat file_does_not_exist && /bin/echo 2 | /bin/echo 3 => ...
cat file_does_not_exist || /bin/echo 2 | /bin/echo 3 => ...
/bin/echo 1 | /bin/echo 2 && /bin/echo 3 => ...
/bin/echo 1 | /bin/echo 2 || /bin/echo 3 => ...
/bin/echo 1 | cat file_does_not_exist && /bin/echo 3 => ...
/bin/echo 1 | cat file_does_not_exist || /bin/echo 3 => ...
cat file_does_not_exist | /bin/echo 2 && /bin/echo 3 => ...
cat file_does_not_exist | /bin/echo 2 || /bin/echo 3 => ...
/bin/echo 1 | /bin/echo 2 && cat file_does_not_exist => ...
/bin/echo 1 | /bin/echo 2 || cat file_does_not_exist => ...
/bin/echo 1 | /bin/echo 2 && /bin/echo 3 | /bin/echo 4 => ...
/bin/echo 1 | /bin/echo 2 || /bin/echo 3 | /bin/echo 4 => ...
/bin/echo 1 | /bin/echo 2 | /bin/echo 3 && /bin/echo 4 | /bin/echo 5 => ...
/bin/echo 1 | /bin/echo 2 | /bin/echo 3 || /bin/echo 4 | /bin/echo 5 => ...
echo <          <         > echo => ...
/usr/bin/printf "%s\n" * | sort => ...
export ARG="*" => ...
/usr/bin/printf "%s\n" $ARG | sort => ...
ls * => ...
ls 'test'* => ...
ls "test"* => ...
touch "*1" => ...
/usr/bin/printf "%s\n" "*"* | sort => ...
rm "*1" => ...
touch "   " => ...
ls * | grep "   " => ...
rm "   " => ...
touch "a" "aa" => ...
/usr/bin/printf "%s\n" *a | sort => ...
rm "a" "aa" => ...
touch "a" "aa" "aaa" => ...
/usr/bin/printf "%s\n" *a*a | sort => ...
rm "a" "aa" "aaa" => ...
/usr/bin/printf "%s\n" "Mak"'e'*'*' | sort => ...
/usr/bin/printf "%s\n" "Mak"'e'** | sort => ...
/usr/bin/printf "%s\n" ***"Mak"'e'** | sort => ...
/usr/bin/printf "%s\n" "."* | sort => ...
/usr/bin/printf "%s\n" *"." | sort => ...
/usr/bin/printf "%s\n" *"."* | sort => ...
/usr/bin/printf "%s\n" "*" | sort => ...
/usr/bin/printf "%s\n" '*' | sort => ...
/usr/bin/printf "%s\n" Minishe*l | sort => ...
/usr/bin/printf "%s\n" minishe*l | sort => ...
touch minishelxxxl => ...
/usr/bin/printf "%s\n" minishe*l | sort => ...
/usr/bin/printf "%s\n" minishel*l | sort => ...
/usr/bin/printf "%s\n" minishelxxx*l | sort => ...
/usr/bin/printf "%s\n" minishel*xxx*l | sort => ...
rm minishelxxxl => ...
touch tmp_out => ...
/bin/echo 42 >tmp_o*t* => ...
rm -f "tmp_out*" => ...
touch tmp_out1 => ...
touch tmp_out2 => ...
/bin/echo 42 >tmp_out* => ...
rm -f "tmp_out*" => ...
export test=" * " => ...
touch "$USER * ?eHallo" => ...
/bin/echo "$USER "*" ?e"* => ...
rm -f "$USER * ?eHallo" => ...
echo "'$HOME'" => ...
echo '"$HOME"' => ...
/bin/echo 1 && /bin/echo 2 || => ...
/bin/echo 1 && /bin/echo 2 | => ...
/bin/echo 1 && /bin/echo 2 && => ...
() => ...
(/bin/echo 1 => ...
/bin/echo 1) => ...
(/bin/echo 1)) => ...
(/bin/echo 1) (/bin/echo 2) => ...
() => ...
(echo) hi => ...
(echo) (hi) => ...
(echo hi && ((echo hi && (echo hi) && echo hi))) => ...
echo <  < <         > ok => ...
echo <  < | echo ok => ...
echo <  < |    < ok => ...
echo <      < |    > echo => ...
echo >>| echo super valid => ...
echo >>< "echo" => ...
echo < < < echo seegf => ...
echo > > < "echo" => ...
echo > > | echo kekw => ...
echo > > | echo super valid => ...
echo < < > echo => ...
echo < < < > ok => ...
echo >>| echo kekw => ...
echo | < echo segf => ...
echo <<| echo ok => ...
echo <<|< ok => ...
echo <<|> echo => ...
echo <<> echo => ...
echo <<<> ok => ...
echo segfault <"<<<"<<amazing => ...
. => ...
amazing => ...
echo seg < > echo seg => ...
echo seg > < echo segf => ...
echo seg < < > echo segf => ...
echo seg < < < > echo segf => ...
echo segf > | echo is this invalid => ...
echo segf < | < echo super valid => ...
echo < < | echo ok => ...
echo < < | < ok => ...
echo < < | > echo => ...
echo segfault < " < < < " < < amazing => ...
. => ...
amazing => ...
echo seg <  > echo seg => ...
echo seg >  < echo segf => ...
echo seg <      < > echo segf => ...
echo seg <      < <    > echo segf => ...
echo <      <     < echo seegf => ...
echo |      < echo segf => ...
echo segf >     | echo is this invalid => ...
echo segf <         |        < echo super valid => ...
echo segfault <"    <   <   <"  <   <   amazing => ...
. => ...
amazing => ...
echo seg <> echo seg => ...
echo seg >< echo segf => ...
echo seg <<> echo segf => ...
echo seg <<<> echo segf => ...
echo <<< echo seegf => ...
echo segf <|< echo super valid => ...
echo test |  <<lala => ...
echo | > la => ...
echo yolo | eco test >> test => ...
echo echo echo echo echo echo => ...
unset $PATH => ...
ECHO -nnnn => ...
unset $PATH => ...
ECHO -n => ...
unset $PATH => ...
ECHo -n => ...
unset $PATH => ...
ECHO "-n" => ...
unset $PATH => ...
EcHO -nnnn => ...
unset $PATH => ...
echo -nnnnnnnn => ...
echo 42 < in | wc -l && ( /bin/echo 1 2 3 4 > tmp_out || /bin/echo 2 > tmp_out >> tmp_out tmp_out ) => ...
rm -f tmp_out => ...
grep 42 < in | wc -l && ( /bin/echo 1 2 3 4 > tmp_out || /bin/echo 2 > tmp_out >> tmp_out tmp_out ) => ...
rm -f tmp_out => ...
(echo 1 && echo 2) | (grep 1 && grep 2) => ...
(printf "Hello\nWorld\n") | (/usr/bin/read -n 3 && cat) => ...
(echo 1 && echo 2) | (/usr/bin/read -n 1 && grep 2) => ...
(echo 1 && echo 2) | (/usr/bin/read -n 1 && grep 1) => ...
/bin/echo 42 | /bin/echo 42 || (/bin/echo 42) => ...
/bin/echo 42 | /bin/echo 42 && (/bin/echo 42) => ...
export bla='||' || echo 42 && echo 43 => ...
export or='||' && export and='&&' && echo 42 $and echo 43 $or echo 43 => ...
