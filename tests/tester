#!/bin/bash

MINISHELL_PATH="../build/bin/minishell"
BASH_CMD=(bash --posix)

# Run a specific test if the file name was specified
if [[ $1 ]]; then
    test_lists=(
        $1
    )
else
    test_lists=(
		"globbing"
        "builtins"
        "pipes"
        "redirects"
        "extras"
        "edge_cases"
        "echo_edge_cases"
        "advanced_edge_cases"
        "arith"
    )
fi

BOLD="\e[1m"
YELLOW="\033[0;33m"
GREY="\033[38;5;244m"
PURPLE="\033[0;35m"
BLUE="\033[0;36m"
RED="\e[0;31m"
END="\033[0m"

chmod 000 ./test_files/invalid_permission
mkdir -p ./outfiles
mkdir -p ./mini_outfiles
mkdir -p ./bash_outfiles

printf $RED
echo "üî• Test harness starting üî•"

# compute a cleaned prompt line (strip ANSI escape sequences using perl)
PROMPT=$(echo -e "\nexit\n" | $MINISHELL_PATH | head -n 1 | perl -pe 's/\e\[[0-9;]*[A-Za-z]//g' )

for testfile in ${test_lists[*]}; do

	printf $RED
	echo ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî $testfile

	while read -r teste; do
		((i++))

		rm -rf ./outfiles/*
		rm -rf ./mini_outfiles/*
		rm -rf ./bash_outfiles/*

		# -------------------------
		# Run minishell with -c, capture stdout/stderr/exitcode to files
		mini_out_tmp=$(mktemp) || mini_out_tmp="/tmp/minishell_tester_out"
		mini_err_tmp=$(mktemp) || mini_err_tmp="/tmp/minishell_tester_err"
		# run the exact command string with -c to avoid stdin/piping differences
		"$MINISHELL_PATH" -c "$teste" >"$mini_out_tmp" 2>"$mini_err_tmp"
		MINI_EXIT_CODE=$?
		MINI_OUTPUT=$(perl -pe 's/\e\[[0-9;]*[A-Za-z]//g' "$mini_out_tmp" | grep -vE '^[[:space:]]*‚ùØ' | grep -v '^exit$' )
		# same: copy produced outfiles if any
		cp ./outfiles/* ./mini_outfiles &>/dev/null || true
		MINI_ERROR_MSG=$(perl -pe 's/\e\[[0-9;]*[A-Za-z]//g' "$mini_err_tmp" | grep -o '[^:]*$' | head -n1 || true)
		rm -f "$mini_out_tmp" "$mini_err_tmp"

		# Clear outfiles so the subsequent bash run starts with an empty outfiles dir.
		# This prevents bash from appending to files already created by minishell.
		rm -rf ./outfiles/*

		# -------------------------
		# Run bash with -c, capture stdout/stderr/exitcode to files
		bash_out_tmp=$(mktemp) || bash_out_tmp="/tmp/bash_tester_out"
		bash_err_tmp=$(mktemp) || bash_err_tmp="/tmp/bash_tester_err"
		# invoke bash as an array to avoid any word-splitting/option ambiguity,
		# pass -- and then the full command as a single argument
		"${BASH_CMD[@]}" -c "$teste" >"$bash_out_tmp" 2>"$bash_err_tmp"
		BASH_EXIT_CODE=$?
		BASH_OUTPUT=$(perl -pe 's/\e\[[0-9;]*[A-Za-z]//g' "$bash_out_tmp" | grep -vE '^[[:space:]]*‚ùØ' | grep -v '^exit$' )
		# copy any produced outfiles (don't capture cp output via substitution)
		cp ./outfiles/* ./bash_outfiles &>/dev/null || true
		BASH_ERROR_MSG=$(perl -pe 's/\e\[[0-9;]*[A-Za-z]//g' "$bash_err_tmp" | grep -o '[^:]*$' | head -n1 || true)
		rm -f "$bash_out_tmp" "$bash_err_tmp"

		OUTFILES_DIFF_BASH=$(diff --brief ./mini_outfiles ./bash_outfiles)

		printf $YELLOW
		printf "Test %3s: " $i
		matched=false
		if [[ "$MINI_OUTPUT" == "$BASH_OUTPUT" && "$MINI_EXIT_CODE" == "$BASH_EXIT_CODE" && -z "$OUTFILES_DIFF_BASH" ]]; then
			matched=true
			ref="bash --posix"
		fi
		if $matched; then
			printf ‚úÖ
			((ok++))
			if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
				printf "‚ö†Ô∏è "
			fi
		else
			printf ‚ùå
		fi
		echo -e "${GREY}${teste}${END}"
		if [ "$OUTFILES_DIFF_BASH" ]; then
			echo "$OUTFILES_DIFF_BASH"
			echo mini outfiles:
			cat ./mini_outfiles/*
			echo bash outfiles:
			cat ./bash_outfiles/*
		fi
		if [ "$MINI_OUTPUT" != "$BASH_OUTPUT" ]; then
			echo mini output = \($MINI_OUTPUT\)
			echo bash output = \($BASH_OUTPUT\)
		fi
		if [ "$MINI_EXIT_CODE" != "$BASH_EXIT_CODE" ]; then
			echo mini exit code = $MINI_EXIT_CODE
			echo bash exit code = $BASH_EXIT_CODE
		fi
		if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
			echo mini error = \($MINI_ERROR_MSG\)
			echo bash error = \($BASH_ERROR_MSG\)
		fi
		done < $testfile
	done

chmod 666 ./test_files/invalid_permission
rm -rf ./outfiles
rm -rf ./mini_outfiles
rm -rf ./bash_outfiles

printf $PURPLE
printf $BOLD
echo   $ok/$i
printf $END

if [[ "$ok" == "$i" ]]; then
	echo "üéä üéä üéä"
	exit 0
else
	echo "üò≠ üò≠ üò≠"
	exit 1
fi
