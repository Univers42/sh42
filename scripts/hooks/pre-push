#!/bin/bash
. "$(dirname "$0")/log_hook.sh"

remote="$1"
url="$2"

FORBIDDEN_PATTERNS=("WIP" "update" "squash!" "debug" "temporary")
PROTECTED_BRANCHES=("main" "master" "develop")
TYPES_REGEX="^(feat|fix|docs|refactor|test)\([^)]+\):[[:space:]]*.+$"
ALLOWED_TYPES="feat, fix, docs, refactor, test"
FORBIDDEN_WORDS="WIP, update, squash!, debug, temporary"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

# detect local committer email â€” we'll only validate commits authored by this user
LOCAL_AUTHOR_EMAIL="$(git config user.email 2>/dev/null || true)"

log_broadcast "PUSH SYSTEM - VALIDATION"

# locate local git dir and possible override file (local only)
GIT_DIR="$(git rev-parse --git-dir 2>/dev/null || echo .git)"
ALLOW_FILE="$GIT_DIR/allow_push"

check_override() {
	# return 0 if override accepted, 1 otherwise
	if [ -f "$ALLOW_FILE" ]; then
		secret="$(sed -n '1p' "$ALLOW_FILE" | tr -d '\r\n')"
		if [ -n "$secret" ]; then
			# env var override (non-interactive, CI)
			if [ -n "$GIT_PUSH_OVERRIDE" ] && [ "$GIT_PUSH_OVERRIDE" = "$secret" ]; then
				log_success "Push override accepted via GIT_PUSH_OVERRIDE."
				return 0
			fi
			# interactive prompt via /dev/tty (works even when stdin isn't a TTY)
			if [ -r /dev/tty ]; then
				printf "Protected-branch push detected. Enter override password (input hidden): " > /dev/tty
				stty -echo < /dev/tty || true
				read -r input_pw < /dev/tty || input_pw=""
				stty echo < /dev/tty || true
				printf "\n" > /dev/tty
				if [ "$input_pw" = "$secret" ]; then
					log_success "Push override accepted."
					return 0
				else
					log_warn "Incorrect override password."
					return 1
				fi
			fi
			# no tty and no env var match -> cannot override
			return 1
		fi
	fi

	# If no allow file present, support non-interactive override only via env var is meaningless;
	# inform user how to enable override locally.
	if [ -n "$GIT_PUSH_OVERRIDE" ]; then
		log_warn "GIT_PUSH_OVERRIDE provided but no local allow file exists; override is disabled."
	fi
	return 1
}

# Confirm prompt helper: return 0 if allowed, 1 otherwise
confirm_push() {
	branch="$1"
	# allow non-interactive auto-confirm via env (useful for CI)
	if [ "${GIT_CONFIRM_PUSH:-}" = "yes" ] || [ "${GIT_CONFIRM_PUSH:-}" = "1" ]; then
		log_info "GIT_CONFIRM_PUSH=yes detected; auto-allowing push to '$branch'."
		return 0
	fi
	# interactive prompt via /dev/tty (works when git isn't feeding stdin)
	if [ -r /dev/tty ]; then
		# default YES when user just presses Enter
		printf "You are about to push to protected branch '%s'. Are you sure you want to continue? [Y/n]: " "$branch" > /dev/tty
		read -r answer < /dev/tty || answer=""
		case "$answer" in
			""|y|Y|yes|YES|Yes)
				log_info "User confirmed push to '$branch'."
				return 0
				;;
			*)
				log_warn "Push to protected branch '$branch' cancelled by user."
				return 1
				;;
		esac
	else
		# no tty and no env var -> cannot confirm interactively
		log_warn "Non-interactive environment detected and GIT_CONFIRM_PUSH not set; rejecting push to protected branch '$branch'."
		return 1
	fi
}

# New helper: interactive ask to continue when bad commit messages exist
ask_continue_on_bad_commits() {
	local branch="$1"
	# non-interactive auto-allow via env
	if [ "${GIT_ALLOW_BAD_COMMIT_MSG:-}" = "yes" ] || [ "${GIT_ALLOW_BAD_COMMIT_MSG:-}" = "1" ]; then
		log_warn "GIT_ALLOW_BAD_COMMIT_MSG=yes detected; allowing push despite commit message issues."
		return 0
	fi
	# prompt via /dev/tty (default YES on empty input)
	if [ -r /dev/tty ]; then
		printf "\nThere are commit message issues on branch '%s'. Continue push anyway? [Y/n]: " "$branch" > /dev/tty
		read -r answer < /dev/tty || answer=""
		case "$answer" in
			""|y|Y|yes|YES|Yes)
				log_info "User confirmed push despite commit message issues."
				return 0
				;;
			*)
				log_warn "Push cancelled by user due to commit message issues."
				return 1
				;;
		esac
	else
		log_warn "Non-interactive environment and GIT_ALLOW_BAD_COMMIT_MSG not set; rejecting push due to commit message issues."
		return 1
	fi
}

# iterate incoming refs and validate commits; collect failures instead of immediate exit
while read local_ref local_oid remote_ref remote_oid; do
	branch="${local_ref##refs/heads/}"

	for pb in "${PROTECTED_BRANCHES[@]}"; do
		if [[ "$branch" == "$pb" ]]; then
			# ask user for confirmation instead of outright blocking
			if check_override; then
				log_info "Override used: allowing push to protected branch '$branch'."
				continue 2
			fi
			if confirm_push "$branch"; then
				log_info "Proceeding with push to protected branch '$branch' after confirmation."
				continue 2
			else
				log_error "Push to protected branch '$branch' denied."
				log_info "Protected branches: ${PROTECTED_BRANCHES[*]}"
				log_warn "Please push to a feature branch and open a pull request instead."
				exit 1
			fi
		fi
	done

	if [[ "$local_oid" = "$zero" ]]; then
		continue
	fi

	if [[ "$remote_oid" = "$zero" ]]; then
		commits=$(git rev-list "$local_oid")
	else
		commits=$(git rev-list "$remote_oid..$local_oid")
	fi

	# Collect failures for this ref
	failures=0
	fail_list_file="$(mktemp)"
	trap 'rm -f "$fail_list_file"' RETURN

	for commit in $commits; do
		# skip validation for commits not authored by the local user (avoid blocking on old/merged commits)
		if [ -n "$LOCAL_AUTHOR_EMAIL" ]; then
			author_email="$(git show -s --format='%ae' "$commit" 2>/dev/null || true)"
			if [ -n "$author_email" ] && [ "$author_email" != "$LOCAL_AUTHOR_EMAIL" ]; then
				# optional debug log (comment out if noisy)
				# log_debug "Skipping commit $commit authored by $author_email (not local $LOCAL_AUTHOR_EMAIL)"
				continue
			fi
		fi

		msg=$(git log -n1 --pretty=format:%B "$commit")
		header=$(printf "%s\n" "$msg" | awk '!/^[[:space:]]*($|#)/{print;exit}')

		# Check header format
		if ! printf "%s" "$header" | grep -Eiq "$TYPES_REGEX"; then
			printf "%s\t%s\tINVALID_HEADER\n" "$commit" "$(echo "$header" | tr '\n' ' ')" >> "$fail_list_file"
			failures=1
			continue
		fi

		# Check description length
		description=$(printf "%s" "$header" | sed -E 's/^(feat|fix|docs|refactor|test)\([^)]+\):[[:space:]]*(.*)$/\2/I')
		len=$(printf '%s' "$description" | wc -c | tr -d '[:space:]')
		if [ "$len" -lt 25 ] || [ "$len" -gt 170 ]; then
			printf "%s\t%s\tBAD_LENGTH(%s)\n" "$commit" "$(echo "$description" | tr '\n' ' ')" "$len" >> "$fail_list_file"
			failures=1
			continue
		fi

		# Forbidden patterns
		for pattern in "${FORBIDDEN_PATTERNS[@]}"; do
			if printf "%s" "$msg" | grep -iqF "$pattern"; then
				printf "%s\t%s\tFORBIDDEN(%s)\n" "$commit" "$(echo "$header" | tr '\n' ' ')" "$pattern" >> "$fail_list_file"
				failures=1
				break
			fi
		done
	done

	# If we collected failures, print a summary and ask the user
	if [ "$failures" -ne 0 ]; then
		log_error "Found commit message issues in the commits to be pushed on branch '$branch':"
		# print the failures in readable form
		while IFS=$'\t' read -r sha info reason; do
			log_info "Commit: $sha"
			log_warn "  Reason: $reason"
			log_example "  Header/Excerpt: $info"
		done < "$fail_list_file"
		# ask whether to continue
		if ask_continue_on_bad_commits "$branch"; then
			log_warn "User allowed push despite commit message issues on branch '$branch'."
			# continue to next ref (do not block)
			continue
		else
			log_error "Push aborted due to commit message issues."
			exit 1
		fi
	fi

done

log_success "All commits passed validation or user allowed them. Push allowed."
exit 0