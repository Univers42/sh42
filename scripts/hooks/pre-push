#!/bin/bash
. "$(dirname "$0")/log_hook.sh"

remote="$1"
url="$2"

FORBIDDEN_PATTERNS=("WIP" "update" "squash!" "debug" "temporary")
PROTECTED_BRANCHES=("main" "master" "develop")
TYPES_REGEX="^(feat|fix|docs|refactor|test)\([^)]+\):[[:space:]]*.+$"
ALLOWED_TYPES="feat, fix, docs, refactor, test"
FORBIDDEN_WORDS="WIP, update, squash!, debug, temporary"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

log_broadcast "PUSH SYSTEM - VALIDATION"

# locate local git dir and possible override file (local only)
GIT_DIR="$(git rev-parse --git-dir 2>/dev/null || echo .git)"
ALLOW_FILE="$GIT_DIR/allow_push"

check_override() {
	# return 0 if override accepted, 1 otherwise
	if [ -f "$ALLOW_FILE" ]; then
		secret="$(sed -n '1p' "$ALLOW_FILE" | tr -d '\r\n')"
		if [ -n "$secret" ]; then
			# env var override (non-interactive, CI)
			if [ -n "$GIT_PUSH_OVERRIDE" ] && [ "$GIT_PUSH_OVERRIDE" = "$secret" ]; then
				log_success "Push override accepted via GIT_PUSH_OVERRIDE."
				return 0
			fi
			# interactive prompt via /dev/tty (works even when stdin isn't a TTY)
			if [ -r /dev/tty ]; then
				printf "Protected-branch push detected. Enter override password (input hidden): " > /dev/tty
				stty -echo < /dev/tty || true
				read -r input_pw < /dev/tty || input_pw=""
				stty echo < /dev/tty || true
				printf "\n" > /dev/tty
				if [ "$input_pw" = "$secret" ]; then
					log_success "Push override accepted."
					return 0
				else
					log_warn "Incorrect override password."
					return 1
				fi
			fi
			# no tty and no env var match -> cannot override
			return 1
		fi
	fi

	# If no allow file present, support non-interactive override only via env var is meaningless;
	# inform user how to enable override locally.
	if [ -n "$GIT_PUSH_OVERRIDE" ]; then
		log_warn "GIT_PUSH_OVERRIDE provided but no local allow file exists; override is disabled."
	fi
	return 1
}

# Confirm prompt helper: return 0 if allowed, 1 otherwise
confirm_push() {
	branch="$1"
	# allow non-interactive auto-confirm via env (useful for CI)
	if [ "${GIT_CONFIRM_PUSH:-}" = "yes" ] || [ "${GIT_CONFIRM_PUSH:-}" = "1" ]; then
		log_info "GIT_CONFIRM_PUSH=yes detected; auto-allowing push to '$branch'."
		return 0
	fi
	# interactive prompt via /dev/tty (works when git isn't feeding stdin)
	if [ -r /dev/tty ]; then
		printf "You are about to push to protected branch '%s'. Are you sure you want to continue? [y/N]: " "$branch" > /dev/tty
		read -r answer < /dev/tty || answer=""
		case "$answer" in
			y|Y|yes|YES|Yes) 
				log_info "User confirmed push to '$branch'."
				return 0
				;;
			*)
				log_warn "Push to protected branch '$branch' cancelled by user."
				return 1
				;;
		esac
	else
		# no tty and no env var -> cannot confirm interactively
		log_warn "Non-interactive environment detected and GIT_CONFIRM_PUSH not set; rejecting push to protected branch '$branch'."
		return 1
	fi
}

while read local_ref local_oid remote_ref remote_oid; do
	branch="${local_ref##refs/heads/}"

	for pb in "${PROTECTED_BRANCHES[@]}"; do
		if [[ "$branch" == "$pb" ]]; then
			# ask user for confirmation instead of outright blocking
			if confirm_push "$branch"; then
				log_info "Proceeding with push to protected branch '$branch' after confirmation."
				continue 2
			else
				log_error "Push to protected branch '$branch' denied."
				log_info "Protected branches: ${PROTECTED_BRANCHES[*]}"
				log_warn "Please push to a feature branch and open a pull request instead."
				exit 1
			fi
		fi
	done

	if [[ "$local_oid" = "$zero" ]]; then
		continue
	fi

	if [[ "$remote_oid" = "$zero" ]]; then
		commits=$(git rev-list "$local_oid")
	else
		commits=$(git rev-list "$remote_oid..$local_oid")
	fi

	for commit in $commits; do
		msg=$(git log -n1 --pretty=format:%B "$commit")
		header=$(printf "%s\n" "$msg" | awk '!/^[[:space:]]*($|#)/{print;exit}')

		if ! printf "%s" "$header" | grep -Eiq "$TYPES_REGEX"; then
			log_error "Commit ${commit} on branch '${branch}' has an invalid header format."
			log_info "Expected format: type(scope): <description>"
			log_info "Allowed types: ${ALLOWED_TYPES}"
			log_example "Example: feat(core): Add support for colored logging in all git hooks"
			exit 1
		fi

		description=$(printf "%s" "$header" | sed -E 's/^(feat|fix|docs|refactor|test)\([^)]+\):[[:space:]]*(.*)$/\2/I')
		len=$(printf '%s' "$description" | wc -c | tr -d '[:space:]')
		if [ "$len" -lt 25 ] || [ "$len" -gt 170 ]; then
			log_error "Commit ${commit} on branch '${branch}' has a description length of $len (must be 25-170)."
			log_info "Your description: \"$description\""
			log_warn "Please provide a more detailed and concise description."
			exit 1
		fi

		for pattern in "${FORBIDDEN_PATTERNS[@]}"; do
			if printf "%s" "$msg" | grep -iqF "$pattern"; then
				log_error "Commit ${commit} on branch '${branch}' contains forbidden pattern: '$pattern'."
				log_warn "Forbidden words: ${FORBIDDEN_WORDS}"
				log_info "Please revise your commit message to remove forbidden words."
				exit 1
			fi
		done
	done
done

log_success "All commits passed validation. Push allowed."
exit 0