#include "../incs/libft/libft.h"
#include "database.h"
#include "../incs/inlexer.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <readline/readline.h>
#include <readline/history.h>

static ssize_t  find_col_index_by_name(t_database *db, const char *name)
{
    size_t  i;

    if (!db || !name)
        return -1;
    for (i = 0; i < db->ncols; ++i)
    {
        if (db->cols[i].name && ft_strcmp(db->cols[i].name, name) == 0)
            return (ssize_t)i;
    }
    return -1;
}

static char *build_real_output_from_tokens(t_tok_vec *vec)
{
    if (!vec)
        return ft_strdup("");
    size_t total = 2; /* for brackets [] */
    for (size_t i = 0; i < vec->count; ++i)
    {
        const char *s = vec->tokens[i]->value.str;
        total += strlen(s);
        if (i + 1 < vec->count)
            total += 1;
    }
    char *out = malloc(total + 1);
    if (!out)
        return ft_strdup("");
    char *p = out;
    *p++ = '[';
    for (size_t i = 0; i < vec->count; ++i)
    {
        const char *s = vec->tokens[i]->value.str;
        size_t n = strlen(s);
        memcpy(p, s, n);
        p += n;
        if (i + 1 < vec->count)
            *p++ = ';';
    }
    *p++ = ']';
    *p = '\0';
    return out;
}

static char uppercase_mapper(unsigned int i, char c)
{
    (void)i;
    if (c >= 'a' && c <= 'z')
        return (char)(c - ('a' - 'A'));
    return c;
}

static const char *token_type_to_str(t_tok_type type)
{
    switch (type)
    {
        case TOK_WORD: return "WORD";
        case TOK_PIPE: return "PIPE";
        case TOK_REDIR_IN: return "REDIR_IN";
        case TOK_REDIR_OUT: return "REDIR_OUT";
        case TOK_HEREDOC: return "HEREDOC";
        case TOK_REDIR_APPEND: return "APPEND";
        default: return "UNKNOWN";
    }
}

static void print_tokens(t_tok_vec *vec)
{
    if (!vec)
    {
        printf("(no tokens)\n");
        return;
    }
    printf("Tokens (count=%zu):\n", vec->count);
    for (size_t i = 0; i < vec->count; ++i)
    {
        const void *vp = vec->tokens[i];
        if (!vp) {
            printf("  [%zu] (null)\n", i);
            continue;
        }
        const char *val = vec->tokens[i]->value.str ? vec->tokens[i]->value.str : "";
        printf("  [%zu] %s : %s\n", i, token_type_to_str(vec->tokens[i]->type), val);
    }
}

int main(int argc, char **argv)
{
    const char *csv_path = "srcs/tests/lexer.csv";
    t_format_style  format = default_style();

    if (argc > 1)
        csv_path = argv[1];

    t_database *db = db_create("Lexer Test Results");
    if (!db)
    {
        fprintf(stderr, "Failed to create database\n");
        return 1;
    }

    /* configure display */
    db->config.show_footer = 1;
    db->config.show_header = 1;
    db->config.show_title = 1;
    db->config.show_title = true;
    db->config.auto_increment_id = true;
    /* tune a softer palette for this test display */
    format.background_header = make_background(40, 60, 90);   /* muted blue header */
    format.background_cell = make_background(210, 210, 210);   /* white cells */
    format.background_body = make_background(248, 249, 251);   /* very light gray background */
    format.background_footer = make_background(240, 240, 245); /* pale footer */
    format.even_row = make_color(50, 50, 50);                   /* dark text for even rows */
    format.title = make_color(70, 110, 170);                   /* soft blue title */
    db_set_footer(db, "Generated by test_lex_db");
    db_set_style(db, format);

    if (db_load_from_csv(db, csv_path) != 0)
    {
        fprintf(stderr, "Failed to load CSV: %s\n", csv_path);
        db_free(db);
        return 1;
    }

    ssize_t col_input = find_col_index_by_name(db, "input");
    ssize_t col_expected = find_col_index_by_name(db, "expected_output");
    ssize_t col_real = find_col_index_by_name(db, "real_output");
    ssize_t col_result = find_col_index_by_name(db, "result");

    if (col_input < 0 || col_expected < 0 || col_real < 0 || col_result < 0)
    {
        fprintf(stderr, "CSV must contain columns: edge_case,input,expected_output,real_output,result\n");
        db_free(db);
        return 1;
    }

    for (size_t r = 0; r < db->nrows; ++r)
    {
        const char *input = "";
        const char *expected = "";
        if (col_input >= 0 && (size_t)col_input < db->rows[r].ncols)
            input = db->rows[r].data[col_input] ? db->rows[r].data[col_input] : "";
        if (col_expected >= 0 && (size_t)col_expected < db->rows[r].ncols)
            expected = db->rows[r].data[col_expected] ? db->rows[r].data[col_expected] : "";

        t_tok_vec *vec = lexer(input);
        char *real_output = build_real_output_from_tokens(vec);

        db_set_cell(db, r, (size_t)col_real, real_output);

        int ok = (ft_strcmp(expected, real_output) == 0);
        db_set_cell(db, r, (size_t)col_result, ok ? "PASS" : "FAIL");

        /* Use ft_strmapi to map result to uppercase and then add ANSI colors */
        if (col_result >= 0 && (size_t)col_result < db->rows[r].ncols)
        {
            char *cell = db->rows[r].data[col_result];
            if (!cell) cell = "";
            char *mapped = ft_strmapi(cell, uppercase_mapper);
            const char *prefix = ok ? "\033[1;32m" : "\033[1;31m"; /* bright green for PASS, bright red for FAIL */
            const char *suffix = "\033[0m";
            size_t buflen = strlen(prefix) + strlen(mapped) + strlen(suffix) + 1;
            char *colored = malloc(buflen);
            if (colored)
            {
                strcpy(colored, prefix);
                strcat(colored, mapped);
                strcat(colored, suffix);
                db_set_cell(db, r, (size_t)col_result, colored);
                free(colored);
            }
            free(mapped);
        }

        free(real_output);
        if (vec)
            vector_free(vec);
    }
    db_render(db);

    /* Interactive mode using GNU readline */
    printf("\nInteractive lexer mode. Type 'quit' to exit.\n");
    char *rl_line;
    for (;;) {
        const char *prompt = "\033[1;34mlexer\033[0m:\033[1;36m> \033[0m";
        rl_line = readline(prompt);
        if (!rl_line) /* EOF */
            break;
        if (rl_line[0] != '\0')
            add_history(rl_line);
        if (ft_strcmp(rl_line, "quit") == 0) {
            free(rl_line);
            break;
        }
        t_tok_vec *ivec = lexer(rl_line);
        if (!ivec)
            printf("Lexer returned NULL (parse error)\n");
        else {
            print_tokens(ivec);
            vector_free(ivec);
        }
        free(rl_line);
    }

    db_free(db);
    return 0;
}
