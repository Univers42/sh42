/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test_lex_db.cpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/22 20:25:17 by dlesieur          #+#    #+#             */
/*   Updated: 2025/12/22 20:43:34 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

extern "C" {
	#include "libft.h"
	#include "inlexer.h"
	#include <stdlib.h>
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static ssize_t find_col_index_by_name(t_database *db, const char *name)
{
	size_t i;
	if (!db || !name)
		return -1;
	for (i = 0; i < db->ncols; ++i)
	{
		if (db->cols[i].name && ft_strcmp(db->cols[i].name, name) == 0)
			return (ssize_t)i;
	}
	return -1;
}

static char *build_real_output_from_tokens(t_tok_vec *vec)
{
	if (!vec)
		return ft_strdup("");
	size_t total = 2; /* for brackets [] */
	for (size_t i = 0; i < vec->count; ++i)
	{
		const char *s = vec->tokens[i]->value.str;
		total += strlen(s);
		if (i + 1 < vec->count)
			total += 1; /* for separator ; */
	}
	char *out = (char*)malloc(total + 1);
	if (!out)
		return ft_strdup("");
	char *p = out;
	*p++ = '[';
	for (size_t i = 0; i < vec->count; ++i)
	{
		const char *s = vec->tokens[i]->value.str;
		size_t n = strlen(s);
		memcpy(p, s, n);
		p += n;
		if (i + 1 < vec->count)
			* p++ = ';';
	}
	*p++ = ']';
	*p = '\0';
	return out;
}

int main(int argc, char **argv)
{
	const char *csv_path = "srcs/tests/lexer.csv";
	if (argc > 1)
		csv_path = argv[1];

	/* create database and load CSV */
	t_database *db = db_create("Lexer Test Results");
	if (!db)
	{
		fprintf(stderr, "Failed to create database\n");
		return 1;
	}

	/* configure display slightly */
	db->config.show_footer = true;
	db->config.show_header = true;
	db->config.show_title = true;
	db_set_footer(db, "Generated by test_lex_db");
	db_set_style(db, default_style());
	db_set_config(db, db->config);

	if (db_load_from_csv(db, csv_path) != 0)
	{
		fprintf(stderr, "Failed to load CSV: %s\n", csv_path);
		db_free(db);
		return 1;
	}

	/* find column indices */
	ssize_t col_edge = find_col_index_by_name(db, "edge_case");
	ssize_t col_input = find_col_index_by_name(db, "input");
	ssize_t col_expected = find_col_index_by_name(db, "expected_output");
	ssize_t col_real = find_col_index_by_name(db, "real_output");
	ssize_t col_result = find_col_index_by_name(db, "result");

	if (col_input < 0 || col_expected < 0 || col_real < 0 || col_result < 0)
	{
		fprintf(stderr, "CSV must contain columns: edge_case,input,expected_output,real_output,result\n");
		db_free(db);
		return 1;
	}

	/* iterate rows and run lexer */
	for (size_t r = 0; r < db->nrows; ++r)
	{
		const char *input = NULL;
		const char *expected = NULL;
		if (col_input < (ssize_t)db->rows[r].ncols)
			input = db->rows[r].data[col_input];
		if (col_expected < (ssize_t)db->rows[r].ncols)
			expected = db->rows[r].data[col_expected];
		if (!input) input = "";
		if (!expected) expected = "";

		/* run lexer and build real_output string */
		t_tok_vec *vec = lexer(input);
		char *real_output = build_real_output_from_tokens(vec);

		/* write real_output into table */
		db_set_cell(db, r, (size_t)col_real, real_output);

		/* compare expected vs real using ft_strcmp */
		int ok = (ft_strcmp(expected, real_output) == 0);
		db_set_cell(db, r, (size_t)col_result, ok ? "PASS" : "FAIL");

		free(real_output);
		if (vec)
			vector_free(vec);
	}

	/* render the table to stdout */
	db_render(db);

	/* cleanup */
	db_free(db);
	return 0;
}